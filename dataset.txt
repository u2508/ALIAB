In the article Build your first chatbot using Python NLTK we wrote a simple python code and built a chatbot. The questions and answers were loosely hardcoded which means the chatbot cannot give satisfactory answers for the questions which are not present in your code. So our chatbot is considered not an intelligent bot.

Here in this article, we will build a document or information-based chatbot that will dive deep into your query and based on that it's going to respond.

Introduction
A chatbot (also known as a talkbot, chatterbot, Bot, IM bot, interactive agent, or Artificial Conversational Entity) is a computer program or an artificial intelligence which conducts a conversation via auditory or textual methods. Such programs are often designed to convincingly simulate how a human would behave as a conversational partner, thereby passing the Turing test. Chatbots are typically used in dialog systems for various practical purposes including customer service or information acquisition. — Wikipedia

Chatbots are hot today. Who doesn't know about them? Chatbots are seen as the future way of interacting with your customers, employees and all other people out there you want to talk to. The essence is that this communication is a dialogue. Contrary to just publishing the information, people who use a chatbot can get to the information they desire more directly by asking questions.

What do Chatbots do?
 
Chatbots are relevant because of the following reasons:

They make available to people, the right information at the right time, right place and most importantly only when they want.
About 90% of our time on mobile is spent on email and messaging platforms. So it makes sense to engage customers using chatbots instead of diverting them to a website or a mobile app.
The advancements in artificial intelligence, machine learning, and natural language processing, allowing bots to converse more and more, like real people.
With chatbots, firms can be available 24/7 to users and visitors. Now, the sales and customer service teams can focus on more complex tasks while the chatbot guides people down the funnel.

Modern chatbots do not rely solely on text, and will often show useful cards, images, links, and forms, providing an app-like experience.

Depending on way bots are programmed, we can categorize them into two variants of chatbots: Rule-Based (dumb bots) & Self Learning (smart bots).

Rule-Based Chatbots: This variety of bots answer questions based on some simple rules that they are trained on.
Self-Learning Chatbots: This variety of bots rely on Artificial Intelligence(AI) & Machine Learning(MI) technologies to converse with users.
Self-learning Chatbots are further divided into Retrieval based and Generative.

Retrieval based

Retrieval based bots work on the principle of directed flows or graphs.The bot is trained to rank the best response from a finite set of predefined responses. The responses here are entered manually, or based on a knowledge base of pre-existing information.

Eg. What are your store timings?
Answer: 9 to 5 pm

These systems can be extended to integrate with 3rd Party systems as well.

Eg. Where is my order?
Answer: It’s on its way and should reach you in 10 mins

Retrieval based bots are the most common types of chatbots that you see today. They allow bot developers and UX to control the experience and match it to the expectations of our customers. They work best for goal-oriented bots in customer support, lead generation and feedback. We can decide the tone of the bot, and design the experience, keeping in mind the customer’s brand and reputation.

Generative

Another method of building chatbots is using a generative model. These chatbots are not built with predefined responses. Instead, they are trained using a large number of previous conversations, based upon which responses to the user are generated. They require a very large amount of conversational data to train.

Generative models are good for conversational chatbots with whom the user is simply looking to exchange banter. These models will virtually always have a response ready for you. However, in many cases, the responses might be arbitrary and not make a lot of sense to you. The chatbot is also prone to generating answers with incorrect grammar and syntax.

Chatbot building
 
There are a few things you need to know before moving forward. Natural Language Processing(NLP) using NLTK, TF-IDF and Cosine similarity.

Natural Language Processing(NLP) using NLTK

Natural language processing (NLP) is the ability of a computer program to understand human language as it is spoken. NLP is a component of artificial intelligence (AI).

The development of NLP applications is challenging because computers traditionally require humans to “speak” to them in a programming language that is precise, unambiguous and highly structured, or through a limited number of clearly enunciated voice commands. Human speech, however, is not always precise — it is often ambiguous and the linguistic structure can depend on many complex variables, including slang, regional dialects, and social context.

Natural Language Toolkit(NLTK)

NLTK is a leading platform for building Python programs to work with human language data. It provides easy-to-use interfaces to over 50 corpora and lexical resources such as WordNet, along with a suite of text processing libraries for classification, tokenization, stemming, tagging, parsing, and semantic reasoning, wrappers for industrial-strength NLP libraries, and an active discussion forum.

TF-IDF

We will compute the Term Frequency-Inverse Document Frequency (TF-IDF) vectors for each document. This will give you a matrix where each column represents a word in the overview vocabulary (all the words that appear in at least one document).

TF-IDF is the statistical method of evaluating the significance of a word in a given document.

TF — Term frequency(tf) refers to how many times a given term appears in a document.

IDF — Inverse document frequency(idf) measures the weight of the word in the document, i.e if the word is common or rare in the entire document.

The TF-IDF intuition follows that the terms that appear frequently in a document are less important than terms that rarely appear.

Fortunately, scikit-learn gives you a built-in TfIdfVectorizer class that produces the TF-IDF matrix quite easily.

Cosine similarity

Now we have this matrix, we can easily compute a similarity score. There are several options to do this; such as the Euclidean, the Pearson, and the cosine similarity scores. Again, there is no right answer to which score is the best.

We will be using the cosine similarity to calculate a numeric quantity that denotes the similarity between the two words. You use the cosine similarity score since it is independent of magnitude and is relatively easy and fast to calculate (especially when used in conjunction with TF-IDF scores). Mathematically, it is defined as follows:

Since we have used the TF-IDF vectorizer, calculating the dot product will directly give us the cosine similarity score. Therefore, we will use sklearn's linear_kernel() instead of cosine_similarities() since it is faster.

Let's start coding…

So we’ll copy data from this website. The dataset contains everything related to Human Resource Management. Copy and paste the whole data in a text format. We’ll train our model based on this data and then check how well the model performs. Apart from this, I have also included Wikipedia python library so you can ask anything.

Importing all the required libraries.

import nltk
import random
import string
import re, string, unicodedata
from nltk.corpus import wordnet as wn
from nltk.stem.wordnet import WordNetLemmatizer
import wikipedia as wk
from collections import defaultdict
import warnings
warnings.filterwarnings("ignore")
nltk.download('punkt') 
nltk.download('wordnet')
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity, linear_kernel


Load the dataset and convert every text into lowercase.

data = open('/../../chatbot/HR.txt','r',errors = 'ignore')
raw = data.read()
raw = raw.lower()


Let us check what our data looks like.

raw[:1000]
'human resource management is the process of recruiting, selecting, inducting employees, providing orientation, imparting training and development, appraising the performance of employees, deciding compensation and providing benefits, motivating employees, maintaining proper relations with employees and their trade unions, ensuring employees safety, welfare and healthy measures in compliance with labour laws of the land.\nhuman resource management involves management functions like planning, organizing, directing and controlling\nit involves procurement, development, maintenance of human resource\nit helps to achieve individual, organizational and social objectives\nhuman resource management is a multidisciplinary subject. it includes the study of management, psychology, communication, economics and sociology.\nit involves team spirit and team work.\nit is a continuous process.\nhuman resource management as a department in an organisation handles all aspects of employees and has various functi'


Data pre-processing

Let us now start with data cleaning and preprocessing by converting the entire data into a list of sentences.

sent_tokens = nltk.sent_tokenize(raw)


Our next step is to normalize these sentences. Normalization is a process that converts a list of words to a more uniform sequence. This is useful in preparing the text for later processing. By transforming the words to a standard format, other operations are able to work with the data and will not have to deal with issues that might compromise the process.

This step involves word tokenization, Removing ASCII values, Removing tags of any kind, Part-of-speech tagging, and Lemmatization.

def Normalize(text):
    remove_punct_dict = dict((ord(punct), None) for punct in string.punctuation)
    #word tokenization
    word_token = nltk.word_tokenize(text.lower().translate(remove_punct_dict))
    
    #remove ascii
    new_words = []
    for word in word_token:
        new_word = unicodedata.normalize('NFKD', word).encode('ascii', 'ignore').decode('utf-8', 'ignore')
        new_words.append(new_word)
    
    #Remove tags
    rmv = []
    for w in new_words:
        text=re.sub("&lt;/?.*?&gt;","&lt;&gt;",w)
        rmv.append(text)
        
    #pos tagging and lemmatization
    tag_map = defaultdict(lambda : wn.NOUN)
    tag_map['J'] = wn.ADJ
    tag_map['V'] = wn.VERB
    tag_map['R'] = wn.ADV
    lmtzr = WordNetLemmatizer()
    lemma_list = []
    rmv = [i for i in rmv if i]
    for token, tag in nltk.pos_tag(rmv):
        lemma = lmtzr.lemmatize(token, tag_map[tag[0]])
        lemma_list.append(lemma)
    return lemma_list


So the data preprocessing part is over now let's define welcome notes or greetings that means if a user provides is a greeting message, the chatbot shall respond with a greeting as well based on keyword matching.

welcome_input = ("hello", "hi", "greetings", "sup", "what's up","hey",)
welcome_response = ["hi", "hey", "*nods*", "hi there", "hello", "I am glad! You are talking to me"]
def welcome(user_response):
    for word in user_response.split():
        if word.lower() in welcome_input:
            return random.choice(welcome_response)


Generate chatbot response

To generate a response from our chatbot for input questions, the concept of document similarity will be used. As I have already discussed the TFidf vectorizer is used to convert a collection of raw documents to a matrix of TF-IDF features and to find the similarity between words entered by the user and the words in the dataset we will use cosine similarity.

We define a function generateResponse() which searches the user’s input words and returns one of several possible responses. If it doesn’t find the input matching any of the keywords then instead of giving just an error message you can ask your chatbot to search Wikipedia for you. Just type “tell me about any_keyword”. Now if it doesn't find anything in Wikipedia the chatbot will generate a message “No content has been found”.

def generateResponse(user_response):
    robo_response=''
    sent_tokens.append(user_response)
    TfidfVec = TfidfVectorizer(tokenizer=Normalize, stop_words='english')
    tfidf = TfidfVec.fit_transform(sent_tokens)
    #vals = cosine_similarity(tfidf[-1], tfidf)
    vals = linear_kernel(tfidf[-1], tfidf)
    idx=vals.argsort()[0][-2]
    flat = vals.flatten()
    flat.sort()
    req_tfidf = flat[-2]
    if(req_tfidf==0) or "tell me about" in user_response:
        print("Checking Wikipedia")
        if user_response:
            robo_response = wikipedia_data(user_response)
            return robo_response
    else:
        robo_response = robo_response+sent_tokens[idx]
        return robo_response#wikipedia search
def wikipedia_data(input):
    reg_ex = re.search('tell me about (.*)', input)
    try:
        if reg_ex:
            topic = reg_ex.group(1)
            wiki = wk.summary(topic, sentences = 3)
            return wiki
    except Exception as e:
            print("No content has been found")


Finally defining the chatbot user conversation handler.

Note: The program will exit if you type Bye, shutdown, exit or quit.

flag=True
print("My name is Chatterbot and I'm a chatbot. If you want to exit, type Bye!")
while(flag==True):
    user_response = input()
    user_response=user_response.lower()
    if(user_response not in ['bye','shutdown','exit', 'quit']):
        if(user_response=='thanks' or user_response=='thank you' ):
            flag=False
            print("Chatterbot : You are welcome..")
        else:
            if(welcome(user_response)!=None):
                print("Chatterbot : "+welcome(user_response))
            else:
                print("Chatterbot : ",end="")
                print(generateResponse(user_response))
                sent_tokens.remove(user_response)
    else:
        flag=False
        print("Chatterbot : Bye!!! ")


Now, let us test our chatbot and see how it responds.

Screenshots of conversation with Chatterbot:





Now if you want your chatbot to search Wikipedia, just type

“tell me about ****”



That was pretty cool, isn't it? Though the results were not precise at least we reached a milestone :)

Conclusion: The future of chatbots
 
The future of Chatbots is very bright. With so much advancement in the Artificial Intelligence sector, chatbots are the future with zero doubt. The current chatbot that we just built is obviously not the future I am talking about as this is just a stepping stone in chatbot building.

The future chatbot will not be just a Customer Support agent, it will be an advance assistant for both the business and consumer.
We as humans are not fond of doing repetitive boring tasks. So in the future companies will hire AI Chatbot for the tasks which are repetitive and don’t require creativity. With AI Chatbot taking over repetitive boring tasks, Companies will utilize their human resources for more creative tasks. With this, we can expect more amazing things coming up to us in the future.

Also, Human doesnt like storing up contents (mugging up) in their mind. And today with the Internet they can leverage that part. So tasks that require storing the information (data) can be transferred to AI Chatbot.

Well, that's all for this article hope you guys have enjoyed reading this it, feel free to share your comments/thoughts/feedback in the comment section.

Please reach me out over LinkedIn for any query.

Thanks for reading!!!
UNIT-1






Computer Logical Organization - Overview


In the modern world of electronics, the term Digital is generally associated with a computer because the term Digital is derived from the way computers perform operation, by counting digits. For many years, the application of digital electronics was only in the computer system. But now-a-days, digital electronics is used in many other applications. Following are some of the examples in which Digital electronics is heavily used.


Industrial process control


Military system


Television


Communication system


Medical equipment


Radar


Navigation


Signal


Signal can be defined as a physical quantity, which contains some information. It is a function of one or more than one independent variables. Signals are of two types.


Analog Signal


Digital Signal


Analog Signal


An analog signal is defined as the signal having continuous values. Analog signal can have infinite number of different values. In real world scenario, most of the things observed in nature are analog. Examples of the analog signals are following.


Temperature


Pressure


Distance


Sound


Voltage


Current


Power


Graphical representation of Analog Signal (Temperature)






The circuits that process the analog signals are called as analog circuits or system. Examples of the analog system are following.


Filter


Amplifiers


Television receiver


Motor speed controller


Disadvantage of Analog Systems


Less accuracy


Less versatility


More noise effect


More distortion


More effect of weather


Digital Signal


A digital signal is defined as the signal which has only a finite number of distinct values. Digital signals are not continuous signals. In the digital electronic calculator, the input is given with the help of switches. This input is converted into electrical signal which have two discrete values or levels. One of these may be called low level and another is called high level. The signal will always be one of the two levels. This type of signal is called digital signal. Examples of the digital signal are following.


Binary Signal


Octal Signal


Hexadecimal Signal


Graphical representation of the Digital Signal (Binary)






The circuits that process the digital signals are called digital systems or digital circuits. Examples of the digital systems are following.


Registers


Flip-flop


Counters


Microprocessors


Advantage of Digital Systems


More accuracy


More versatility


Less distortion


Easy communicate


Possible storage of information


Comparison of Analog and Digital Signal


S.N.


Analog Signal


Digital Signal


1


Analog signal has infinite values.


Digital signal has a finite number of values.


2


Analog signal has a continuous nature.


Digital signal has a discrete nature.


3


Analog signal is generated by transducers and signal generators.


Digital signal is generated by A to D converter.


4


Example of analog signal − sine wave, triangular waves.


Example of digital signal − binary signal.










Digital Number System


A digital system can understand positional number system only where there are a few symbols called digits and these symbols represent different values depending on the position they occupy in the number.


A value of each digit in a number can be determined using


The digit


The position of the digit in the number


The base of the number system (where base is defined as the total number of digits available in the number system).


Decimal Number System


The number system that we use in our day-to-day life is the decimal number system. Decimal number system has base 10 as it uses 10 digits from 0 to 9. In decimal number system, the successive positions to the left of the decimal point represents units, tens, hundreds, thousands and so on.


Each position represents a specific power of the base (10). For example, the decimal number 1234 consists of the digit 4 in the units position, 3 in the tens position, 2 in the hundreds position, and 1 in the thousands position, and its value can be written as


(1×1000) + (2×100) + (3×10) + (4×l)


(1×103) + (2×102) + (3×101)  + (4×l00)


1000 + 200 + 30 + 1


1234


As a computer programmer or an IT professional, you should understand the following number systems which are frequently used in computers.


S.N.


Number System & Description


1


Binary Number System


Base 2. Digits used: 0, 1


2


Octal Number System


Base 8. Digits used: 0 to 7


3


Hexa Decimal Number System


Base 16. Digits used: 0 to 9, Letters used: A- F


Binary Number System


Characteristics


Uses two digits, 0 and 1.


Also called base 2 number system


Each position in a binary number represents a 0 power of the base (2). Example: 20


Last position in a binary number represents an x power of the base (2). Example: 2x where x represents the last position - 1.


Example


Binary Number: 101012


Calculating Decimal Equivalent −


Step


Binary Number


Decimal Number


Step 1


101012


((1 × 24) + (0 × 23) + (1 × 22) + (0 × 21) + (1 × 20))10


Step 2


101012


(16 + 0 + 4 + 0 + 1)10


Step 3


101012


2110


Note: 101012 is normally written as 10101.


Octal Number System


Characteristics


Uses eight digits, 0,1,2,3,4,5,6,7.


Also called base 8 number system


Each position in an octal number represents a 0 power of the base (8). Example: 80


Last position in an octal number represents an x power of the base (8). Example: 8x where x represents the last position - 1.


Example


Octal Number − 125708


Calculating Decimal Equivalent −


Step


Octal Number


Decimal Number


Step 1


125708


((1 × 84) + (2 × 83) + (5 × 82) + (7 × 81) + (0 × 80))10


Step 2


125708


(4096 + 1024 + 320 + 56 + 0)10


Step 3


125708


549610


Note: 125708 is normally written as 12570.


Hexadecimal Number System


Characteristics


Uses 10 digits and 6 letters, 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F.


Letters represents numbers starting from 10. A = 10, B = 11, C = 12, D = 13, E = 14, F = 15.


Also called base 16 number system.


Each position in a hexadecimal number represents a 0 power of the base (16). Example 160.


Last position in a hexadecimal number represents an x power of the base (16). Example 16x where x represents the last position - 1.


Example −


Hexadecimal Number: 19FDE16


Calculating Decimal Equivalent −


Step


Hexadecimal Number


Decimal Number


Step 1


19FDE16


((1 × 164) + (9 × 163) + (F × 162) + (D × 161) + (E × 160))10


Step 2


19FDE16


((1 × 164) + (9 × 163) + (15 × 162) + (13 × 161) + (14 × 160))10


Step 3


19FDE16


(65536 + 36864 + 3840 + 208 + 14)10


Step 4


19FDE16


10646210


Note − 19FDE16 is normally written as 19FDE.


Number System Conversion


There are many methods or techniques which can be used to convert numbers from one base to another. We'll demonstrate here the following −


Decimal to Other Base System


Other Base System to Decimal


Other Base System to Non-Decimal


Shortcut method − Binary to Octal


Shortcut method − Octal to Binary


Shortcut method − Binary to Hexadecimal


Shortcut method − Hexadecimal to Binary


Decimal to Other Base System


Steps


Step 1 − Divide the decimal number to be converted by the value of the new base.


Step 2 − Get the remainder from Step 1 as the rightmost digit (least significant digit) of new base number.


Step 3 − Divide the quotient of the previous divide by the new base.


Step 4 − Record the remainder from Step 3 as the next digit (to the left) of the new base number.


Repeat Steps 3 and 4, getting remainders from right to left, until the quotient becomes zero in Step 3.


The last remainder thus obtained will be the Most Significant Digit (MSD) of the new base number.


Example −


Decimal Number: 2910


Calculating Binary Equivalent −


Step


Operation


Result


Remainder


Step 1


29 / 2


14


1


Step 2


14 / 2


7


0


Step 3


7 / 2


3


1


Step 4


3 / 2


1


1


Step 5


1 / 2


0


1


As mentioned in Steps 2 and 4, the remainders have to be arranged in the reverse order so that the first remainder becomes the Least Significant Digit (LSD) and the last remainder becomes the Most Significant Digit (MSD).


Decimal Number − 2910 = Binary Number − 111012.


Other Base System to Decimal System


Steps


Step 1 − Determine the column (positional) value of each digit (this depends on the position of the digit and the base of the number system).


Step 2 − Multiply the obtained column values (in Step 1) by the digits in the corresponding columns.


Step 3 − Sum the products calculated in Step 2. The total is the equivalent value in decimal.


Example


Binary Number − 111012


Calculating Decimal Equivalent −


Step


Binary Number


Decimal Number


Step 1


111012


((1 × 24) + (1 × 23) + (1 × 22) + (0 × 21) + (1 × 20))10


Step 2


111012


(16 + 8 + 4 + 0 + 1)10


Step 3


111012


2910


Binary Number − 111012 = Decimal Number − 2910


Other Base System to Non-Decimal System


Steps


Step 1 − Convert the original number to a decimal number (base 10).


Step 2 − Convert the decimal number so obtained to the new base number.


Example


Octal Number − 258


Calculating Binary Equivalent −


Step 1 − Convert to Decimal


Step


Octal Number


Decimal Number


Step 1


258


((2 × 81) + (5 × 80))10


Step 2


258


(16 + 5 )10


Step 3


258


2110


Octal Number − 258 = Decimal Number − 2110


Step 2 − Convert Decimal to Binary


Step


Operation


Result


Remainder


Step 1


21 / 2


10


1


Step 2


10 / 2


5


0


Step 3


5 / 2


2


1


Step 4


2 / 2


1


0


Step 5


1 / 2


0


1


Decimal Number − 2110 = Binary Number − 101012


Octal Number − 258 = Binary Number − 101012


Shortcut method - Binary to Octal


Steps


Step 1 − Divide the binary digits into groups of three (starting from the right).


Step 2 − Convert each group of three binary digits to one octal digit.


Example


Binary Number − 101012


Calculating Octal Equivalent −


Step


Binary Number


Octal Number


Step 1


101012


010 101


Step 2


101012


28 58


Step 3


101012


258


Binary Number − 101012 = Octal Number − 258


Shortcut method - Octal to Binary


Steps


Step 1 − Convert each octal digit to a 3 digit binary number (the octal digits may be treated as decimal for this conversion).


Step 2 − Combine all the resulting binary groups (of 3 digits each) into a single binary number.


Example


Octal Number − 258


Calculating Binary Equivalent −


Step


Octal Number


Binary Number


Step 1


258


210 510


Step 2


258


0102 1012


Step 3


258


0101012


Octal Number − 258 = Binary Number − 101012


Shortcut method - Binary to Hexadecimal


Steps


Step 1 − Divide the binary digits into groups of four (starting from the right).


Step 2 − Convert each group of four binary digits to one hexadecimal symbol.


Example


Binary Number − 101012


Calculating hexadecimal Equivalent −


Step


Binary Number


Hexadecimal Number


Step 1


101012


0001 0101


Step 2


101012


110 510


Step 3


101012


1516


Binary Number − 101012 = Hexadecimal Number − 1516


Shortcut method - Hexadecimal to Binary


Steps


Step 1 − Convert each hexadecimal digit to a 4 digit binary number (the hexadecimal digits may be treated as decimal for this conversion).


Step 2 − Combine all the resulting binary groups (of 4 digits each) into a single binary number.


Example


Hexadecimal Number − 1516


Calculating Binary Equivalent −


Step


Hexadecimal Number


Binary Number


Step 1


1516


110 510


Step 2


1516


00012 01012


Step 3


1516


000101012


Hexadecimal Number − 1516 = Binary Number − 101012


Binary Codes


In the coding, when numbers, letters or words are represented by a specific group of symbols, it is said that the number, letter or word is being encoded. The group of symbols is called as a code. The digital data is represented, stored and transmitted as group of binary bits. This group is also called as binary code. The binary code is represented by the number as well as alphanumeric letter.


Advantages of Binary Code


Following is the list of advantages that binary code offers.


Binary codes are suitable for the computer applications.


Binary codes are suitable for the digital communications.


Binary codes make the analysis and designing of digital circuits if we use the binary codes.


Since only 0 & 1 are being used, implementation becomes easy.


Classification of binary codes


The codes are broadly categorized into following four categories.


Weighted Codes


Non-Weighted Codes


Binary Coded Decimal Code


Alphanumeric Codes


Error Detecting Codes


Error Correcting Codes


Weighted Codes


Weighted binary codes are those binary codes which obey the positional weight principle. Each position of the number represents a specific weight. Several systems of the codes are used to express the decimal digits 0 through 9. In these codes each decimal digit is represented by a group of four bits.






Non-Weighted Codes


In this type of binary codes, the positional weights are not assigned. The examples of non-weighted codes are Excess-3 code and Gray code.


Excess-3 code


The Excess-3 code is also called as XS-3 code. It is non-weighted code used to express decimal numbers. The Excess-3 code words are derived from the 8421 BCD code words adding (0011)2 or (3)10 to each code word in 8421. The excess-3 codes are obtained as follows −






Example






Gray Code


It is the non-weighted code and it is not arithmetic codes. That means there are no specific weights assigned to the bit position. It has a very special feature that, only one bit will change each time the decimal number is incremented as shown in fig. As only one bit changes at a time, the gray code is called as a unit distance code. The gray code is a cyclic code. Gray code cannot be used for arithmetic operation.






Application of Gray code


Gray code is popularly used in the shaft position encoders.


A shaft position encoder produces a code word which represents the angular position of the shaft.


Binary Coded Decimal (BCD) code


In this code each decimal digit is represented by a 4-bit binary number. BCD is a way to express each of the decimal digits with a binary code. In the BCD, with four bits we can represent sixteen numbers (0000 to 1111). But in BCD code only first ten of these are used (0000 to 1001). The remaining six code combinations i.e. 1010 to 1111 are invalid in BCD.






Advantages of BCD Codes


It is very similar to decimal system.


We need to remember binary equivalent of decimal numbers 0 to 9 only.


Disadvantages of BCD Codes


The addition and subtraction of BCD have different rules.


The BCD arithmetic is little more complicated.


BCD needs more number of bits than binary to represent the decimal number. So BCD is less efficient than binary.


Alphanumeric codes


A binary digit or bit can represent only two symbols as it has only two states '0' or '1'. But this is not enough for communication between two computers because there we need many more symbols for communication. These symbols are required to represent 26 alphabets with capital and small letters, numbers from 0 to 9, punctuation marks and other symbols.


The alphanumeric codes are the codes that represent numbers and alphabetic characters. Mostly such codes also represent other characters such as symbol and various instructions necessary for conveying information. An alphanumeric code should at least represent 10 digits and 26 letters of alphabet i.e. total 36 items. The following three alphanumeric codes are very commonly used for the data representation.


American Standard Code for Information Interchange (ASCII).


Extended Binary Coded Decimal Interchange Code (EBCDIC).


Five bit Baudot Code.


ASCII code is a 7-bit code whereas EBCDIC is an 8-bit code. ASCII code is more commonly used worldwide while EBCDIC is used primarily in large IBM computers.


Error Codes


There are binary code techniques available to detect and correct data during data transmission.


Error Code


Description


Error Detection and Correction


Error detection and correction code techniques










Codes Conversion


There are many methods or techniques which can be used to convert code from one format to another. We'll demonstrate here the following


Binary to BCD Conversion


BCD to Binary Conversion


BCD to Excess-3


Excess-3 to BCD


Binary to BCD Conversion


Steps


Step 1 -- Convert the binary number to decimal.


Step 2 -- Convert decimal number to BCD.


Example − convert (11101)2 to BCD.


Step 1 − Convert to Decimal


Binary Number − 111012


Calculating Decimal Equivalent −


Step


Binary Number


Decimal Number


Step 1


111012


((1 × 24) + (1 × 23) + (1 × 22) + (0 × 21) + (1 × 20))10


Step 2


111012


(16 + 8 + 4 + 0 + 1)10


Step 3


111012


2910


Binary Number − 111012 = Decimal Number − 2910


Step 2 − Convert to BCD


Decimal Number − 2910


Calculating BCD Equivalent. Convert each digit into groups of four binary digits equivalent.


Step


Decimal Number


Conversion


Step 1


2910


00102 10012


Step 2


2910


00101001BCD


Result


(11101)2 =  (00101001)BCD


BCD to Binary Conversion


Steps


Step 1 -- Convert the BCD number to decimal.


Step 2 -- Convert decimal to binary.


Example − convert (00101001)BCD to Binary.


Step 1 - Convert to BCD


BCD Number − (00101001)BCD


Calculating Decimal Equivalent. Convert each four digit into a group and get decimal equivalent for each group.


Step


BCD Number


Conversion


Step 1


(00101001)BCD


00102 10012


Step 2


(00101001)BCD


210 910


Step 3


(00101001)BCD


2910


BCD Number − (00101001)BCD = Decimal Number − 2910


Step 2 - Convert to Binary


Used long division method for decimal to binary conversion.


Decimal Number − 2910


Calculating Binary Equivalent −


Step


Operation


Result


Remainder


Step 1


29 / 2


14


1


Step 2


14 / 2


7


0


Step 3


7 / 2


3


1


Step 4


3 / 2


1


1


Step 5


1 / 2


0


1


As mentioned in Steps 2 and 4, the remainders have to be arranged in the reverse order so that the first remainder becomes the least significant digit (LSD) and the last remainder becomes the most significant digit (MSD).


Decimal Number − 2910 = Binary Number − 111012


Result


(00101001)BCD = (11101)2


BCD to Excess-3


Steps


Step 1 -- Convert BCD to decimal.


Step 2 -- Add (3)10 to this decimal number.


Step 3 -- Convert into binary to get excess-3 code.


Example − convert (0110)BCD to Excess-3.


Step 1 − Convert to decimal


(0110)BCD = 610


Step 2 − Add 3 to decimal


(6)10 + (3)10 = (9)10


Step 3 − Convert to Excess-3


(9)10 = (1001)2


Result


(0110)BCD = (1001)XS-3


Excess-3 to BCD Conversion


Steps


Step 1 -- Subtract (0011)2 from each 4 bit of excess-3 digit to obtain the corresponding BCD code.


Example − convert (10011010)XS-3 to BCD.


Given XS-3 number  = 1 0 0 1 1 0 1 0 


Subtract (0011)2   = 1 0 0 1 0 1 1 1


                    --------------------


               BCD = 0 1 1 0   0 1 1 1


Result


(10011010)XS-3 = (01100111)BCD


Complement Arithmetic


Complements are used in the digital computers in order to simplify the subtraction operation and for the logical manipulations. For each radix-r system (radix r represents base of number system) there are two types of complements.


S.N.


Complement


Description


1


Radix Complement


The radix complement is referred to as the r's complement


2


Diminished Radix Complement


The diminished radix complement is referred to as the (r-1)'s complement


Binary system complements


As the binary system has base r = 2. So the two types of complements for the binary system are 2's complement and 1's complement.


1's complement


The 1's complement of a number is found by changing all 1's to 0's and all 0's to 1's. This is called as taking complement or 1's complement. Example of 1's Complement is as follows.






2's complement


The 2's complement of binary number is obtained by adding 1 to the Least Significant Bit (LSB) of 1's complement of the number.


2's complement = 1's complement + 1


Example of 2's Complement is as follows.






Binary Arithmetic


Binary arithmetic is essential part of all the digital computers and many other digital system.


Binary Addition


It is a key for binary subtraction, multiplication, division. There are four rules of binary addition.






In fourth case, a binary addition is creating a sum of (1 + 1 = 10) i.e. 0 is written in the given column and a carry of 1 over to the next column.


Example − Addition






Binary Subtraction


Subtraction and Borrow, these two words will be used very frequently for the binary subtraction. There are four rules of binary subtraction.






Example − Subtraction






Binary Multiplication


Binary multiplication is similar to decimal multiplication. It is simpler than decimal multiplication because only 0s and 1s are involved. There are four rules of binary multiplication.






Example − Multiplication






Binary Division


Binary division is similar to decimal division. It is called as the long division procedure.


Example − Division






Octal Arithmetic


Octal Number System


Following are the characteristics of an octal number system.


Uses eight digits, 0,1,2,3,4,5,6,7.


Also called base 8 number system.


Each position in an octal number represents a 0 power of the base (8). Example: 80


Last position in an octal number represents an x power of the base (8). Example: 8x where x represents the last position - 1.


Example


Octal Number − 125708


Calculating Decimal Equivalent −


Step


Octal Number


Decimal Number


Step 1


125708


((1 × 84) + (2 × 83) + (5 × 82) + (7 × 81) + (0 × 80))10


Step 2


125708


(4096 + 1024 + 320 + 56 + 0)10


Step 3


125708


549610


Note − 125708 is normally written as 12570.


Octal Addition


Following octal addition table will help you to handle octal addition.






To use this table, simply follow the directions used in this example: Add 68 and 58. Locate 6 in the A column then locate the 5 in the B column. The point in 'sum' area where these two columns intersect is the 'sum' of two numbers.


68 + 58 = 138.


Example − Addition






Octal Subtraction


The subtraction of octal numbers follows the same rules as the subtraction of numbers in any other number system. The only variation is in borrowed number. In the decimal system, you borrow a group of 1010. In the binary system, you borrow a group of 210. In the octal system you borrow a group of 810.


Example − Subtraction






 


Hexadecimal Arithmetic


Hexadecimal Number System


Following are the characteristics of a hexadecimal number system.


Uses 10 digits and 6 letters, 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F.


Letters represents numbers starting from 10. A = 10, B = 11, C = 12, D = 13, E = 14, F = 15.


Also called base 16 number system.


Each position in a hexadecimal number represents a 0 power of the base (16). Example − 160


Last position in a hexadecimal number represents an x power of the base (16). Example − 16x where x represents the last position - 1.


Example


Hexadecimal Number − 19FDE16


Calculating Decimal Equivalent −


Step


Hexadecimal Number


Decimal Number


Step 1


19FDE16


((1 × 164) + (9 × 163) + (F × 162) + (D × 161) + (E × 160))10


Step 2


19FDE16


((1 × 164) + (9 × 163) + (15 × 162) + (13 × 161) + (14 × 160))10


Step 3


19FDE16


(65536 + 36864 + 3840 + 208 + 14)10


Step 4


19FDE16


10646210


Note − 19FDE16 is normally written as 19FDE.


Hexadecimal Addition


Following hexadecimal addition table will help you greatly to handle Hexadecimal addition.






To use this table, simply follow the directions used in this example − Add A16 and 516. Locate A in the X column then locate the 5 in the Y column. The point in 'sum' area where these two columns intersect is the sum of two numbers.


A16 + 516 = F16.


Example − Addition






Hexadecimal Subtraction


The subtraction of hexadecimal numbers follow the same rules as the subtraction of numbers in any other number system. The only variation is in borrowed number. In the decimal system, you borrow a group of 1010. In the binary system, you borrow a group of 210. In the hexadecimal system you borrow a group of 1610.


Example - Subtraction






 


Logic Gates






Logic gates are the basic building blocks of any digital system. It is an electronic circuit having one or more than one input and only one output. The relationship between the input and the output is based on a certain logic. Based on this, logic gates are named as AND gate, OR gate, NOT gate etc.


AND Gate


A circuit which performs an AND operation is shown in figure. It has n input (n >= 2) and one output.






Logic diagram






Truth Table






OR Gate


A circuit which performs an OR operation is shown in figure. It has n input (n >= 2) and one output.






Logic diagram






Truth Table






NOT Gate


NOT gate is also known as Inverter. It has one input A and one output Y.






Logic diagram






Truth Table






NAND Gate


A NOT-AND operation is known as NAND operation. It has n input (n >= 2) and one output.






Logic diagram






Truth Table






NOR Gate


A NOT-OR operation is known as NOR operation. It has n input (n >= 2) and one output.






Logic diagram






Truth Table






XOR Gate


XOR or Ex-OR gate is a special type of gate. It can be used in the half adder, full adder and subtractor. The exclusive-OR gate is abbreviated as EX-OR gate or sometime as X-OR gate. It has n input (n >= 2) and one output.






Logic diagram






Truth Table






XNOR Gate


XNOR gate is a special type of gate. It can be used in the half adder, full adder and subtractor. The exclusive-NOR gate is abbreviated as EX-NOR gate or sometime as X-NOR gate. It has n input (n >= 2) and one output.






Logic diagram






Truth Table






